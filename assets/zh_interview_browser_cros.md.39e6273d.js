import{_ as e,o as i,c as o,N as a}from"./chunks/framework.c893c7c5.js";const w=JSON.parse('{"title":"跨域","description":"","frontmatter":{},"headers":[],"relativePath":"zh/interview/browser/cros.md"}'),l={name:"zh/interview/browser/cros.md"},r=a('<h1 id="跨域" tabindex="-1">跨域 <a class="header-anchor" href="#跨域" aria-label="Permalink to &quot;跨域&quot;">​</a></h1><h2 id="什么是跨域" tabindex="-1">什么是跨域？ <a class="header-anchor" href="#什么是跨域" aria-label="Permalink to &quot;什么是跨域？&quot;">​</a></h2><p>跨域（Cross-Origin）是指在浏览器中，当一个网页的脚本（如JavaScript）试图访问不同域名、不同协议或不同端口的资源时，就会发生跨域请求。浏览器出于安全考虑，限制了这种跨域资源访问。</p><p>在 Web 安全模型中，浏览器会将网页的源（Origin）定义为协议、域名和端口的组合。如果两个网页的源不完全匹配，就被视为跨域请求。</p><p>跨域请求的限制是出于安全目的，以防止恶意网站利用用户的浏览器发起对其他网站的攻击，从而保护用户的隐私和安全。跨域请求可能涉及敏感数据的泄露、恶意代码的注入等安全风险。</p><p>例如，以下是几种常见的跨域场景：</p><ul><li>协议不匹配：从 HTTP 页面向 HTTPS 页面发起请求。</li><li>域名不匹配：从 www.example.com 页面向 api.example.com 发起请求。</li><li>端口不匹配：从 www.example.com:8080 页面向 www.example.com:3000 发起请求。</li></ul><p>要在跨域请求时进行合法的访问，可以使用以下方法：</p><ol><li>JSONP（JSON with Padding）：通过动态创建&lt;script&gt;标签来加载跨域的JavaScript资源，并在请求参数中传递回调函数。</li><li>CORS（Cross-Origin Resource Sharing）：通过服务器设置响应头部，允许指定域名的请求访问资源。</li><li>代理服务器：通过在自己的服务器上创建代理，将跨域请求转发到目标服务器并返回结果。</li></ol><p>需要注意的是，跨域问题只存在于浏览器环境中。服务器之间的请求可以自由跨域，不受浏览器的限制。因此，在开发应用程序时，需要注意处理跨域请求的安全性和可靠性。</p><h2 id="浏览器是如何限制跨域请求的" tabindex="-1">浏览器是如何限制跨域请求的？ <a class="header-anchor" href="#浏览器是如何限制跨域请求的" aria-label="Permalink to &quot;浏览器是如何限制跨域请求的？&quot;">​</a></h2><p>浏览器通过一些安全机制来限制跨域请求，以保护用户的隐私和安全。以下是浏览器常用的几种限制跨域请求的机制：</p><ol><li><p>同源策略（Same-Origin Policy）： 同源策略是浏览器的基本安全策略之一，它要求网页脚本（如JavaScript）只能访问与其来源相同的资源。同源是指协议、域名和端口号完全相同。如果资源的来源与当前网页的来源不同，就会被认为是跨域请求，受到同源策略的限制。</p></li><li><p>跨域请求限制： 当浏览器发现脚本尝试发送跨域请求时，它会阻止该请求的发送，除非目标服务器明确允许该请求。这是通过在服务器端设置响应头部来实现的。常用的响应头部包括Access-Control-Allow-Origin（指定允许的源）、Access-Control-Allow-Methods（指定允许的请求方法）和Access-Control-Allow-Headers（指定允许的请求头）等。</p></li><li><p>Cookie限制： 浏览器默认情况下不会发送跨域请求的Cookie信息。跨域请求可以通过设置withCredentials属性为true来允许发送Cookie，但前提是服务器明确允许接收跨域请求的Cookie。否则，浏览器会忽略跨域请求的Cookie。</p></li><li><p>跨域脚本防护： 浏览器会对从跨域资源加载的脚本进行特殊处理，例如不允许读取其内容或执行其中的敏感操作。这是为了防止跨域脚本攻击（XSS攻击）。</p></li></ol><p>需要注意的是，跨域限制是由浏览器实施的安全机制，并非服务器端的限制。服务器可以通过CORS头部设置来明确指定允许的跨域请求，以解除浏览器的限制。同时，开发者也可以采用其他跨域解决方案，如JSONP、代理服务器等，来绕过跨域限制。然而，这些解决方案仍需谨慎处理，以确保应用程序的安全性。</p>',14),t=[r];function s(c,p,n,_,d,h){return i(),o("div",null,t)}const S=e(l,[["render",s]]);export{w as __pageData,S as default};
